uses data.json.JSONParser;

component provides BSON requires io.Output out, data.IntUtil iu, data.StringUtil su, database.ByteUtil bu{

  BSONDocument BSON:serialise(JSONElement json){

    BSONDocument bsonFromJson = digestJSONElement(json);

    //prepend document size including the size of the number, and the byte for the null terminator
    bsonFromJson.value = new byte[](bu.toLittleEndian(bsonFromJson.value.arrayLength + 5),bsonFromJson.value);

    //append document terminator
    bsonFromJson.value = new byte[](bsonFromJson.value, BSON_NULL_TERMINATOR);

    out.println(" TOTAL LENGTH: $(iu.intToString(bsonFromJson.value.arrayLength))");


    return bsonFromJson;
  }

  JSONElement BSON:deserialise(BSONDocument bson){
    return new JSONElement(JSON_ELEMENT_OBJECT, "", "", digestBSONDocument(bson));
  }

  BSONDocument[] BSON:parse(byte bsonDocuments[]){

    BSONDocument docs[];

    int byteCount = 0;

    while(byteCount < bsonDocuments.arrayLength){
      int32 size = bu.toInteger(bu.reverse(su.subString(bsonDocuments,byteCount,4)));

      docs = new BSONDocument[](docs, new BSONDocument(su.subString(bsonDocuments,byteCount,size)));

      byteCount += size;
    }

    return docs;
  }

  void serialiseName(char value[], BSONDocument bson){
    bson.value = new byte[](bson.value, value, BSON_NULL_TERMINATOR);
  }

  void serialiseString(char value[], BSONDocument bson){
    bson.value = new byte[](bson.value, value, BSON_NULL_TERMINATOR);
  }

  void serialiseNumber(char value[], BSONDocument bson){
    bson.value = new byte[](bson.value, bu.toLittleEndian(iu.intFromString(value)));
  }

  void serialiseBoolean(char value[], BSONDocument bson){
    if(su.iequal(value,"true"))
      bson.value = new byte[](bson.value, BSON_BOOL_TRUE);
    else
      bson.value = new byte[](bson.value, BSON_BOOL_FALSE);
  }

  BSONDocument digestJSONElement(JSONElement element){

    BSONDocument bson = new BSONDocument("");

    if(element.name == "_id"){

      out.println("WE ARE IN ID");

      //add our type
      bson.value = new byte[](bson.value, BSON_OBJECT_ID);

      if(element.name.arrayLength  == 0)
        throw new Exception("Strings must have an associated name, unless they are in an array");

      //add our name
      serialiseName(element.name, bson);

      //get the length of the data (Plus one for null terminator)
      bson.value = new byte[](bson.value, element.value);

      //resolve
      return bson;
    }

    if(element.type == JSON_ELEMENT_OBJECT){

      out.println("OBJECT!!!");

      /*
        if this element doesn't have a name - we can presume we are digesting
        for the first time.

        TODO:
        It may make more sense to pass a bool on first iteration, and throw
        an error on parsing an object without a name, in subsequent iterations
      */

      if(element.name.arrayLength > 0){
        out.println("NAME: $(element.name)");
        //add our type
        bson.value = new byte[](bson.value, BSON_EMBEDDED_DOCUMENT);

        //add our name
        serialiseName(element.name, bson);
      }

      /*
        For this, we need to know the size of our children, thereby their structures.

        We then recursively descend into each child element, and resolve by combining
        the child with the children bson document
      */
      BSONDocument children = new BSONDocument("");

      out.println("OBJECT LENGTH $(iu.intToString(element.children.arrayLength))");

      for(int i = 0; i < element.children.arrayLength; i++){

        out.println("$(iu.intToString(i))-- OBJECT CHILD:$(iu.intToString(element.children[i].type)) || $(element.children[i].name) || $(element.children[i].value)");

        BSONDocument newChild = digestJSONElement(element.children[i]);

        children.value = new byte[](children.value, newChild.value);
      }

      //after we have returned, combine the children, the childrens length
      //with our bson document.
      //it's inclusive so add 4 for an int32
      if(element.name.arrayLength > 0)
        bson.value = new byte[](bson.value,bu.toLittleEndian(children.value.arrayLength + 5), children.value, BSON_NULL_TERMINATOR);
      else
        bson.value = new byte[](bson.value,children.value);

      //resolve
      return bson;
    }

    if(element.type == JSON_ELEMENT_STRING){
      //add our type
      bson.value = new byte[](bson.value, BSON_UTF8);

      if(element.name.arrayLength  == 0)
        throw new Exception("Strings must have an associated name, unless they are in an array");

      //add our name
      serialiseName(element.name, bson);

      //get the length of the data (Plus one for null terminator)
      bson.value = new byte[](bson.value, bu.toLittleEndian(element.value.arrayLength + 1));

      //add the string
      serialiseString(element.value, bson);

      return bson;
    }

    if(element.type == JSON_ELEMENT_NUMBER){

      bson.value = new byte[](bson.value, BSON_INT_32);

      serialiseName(element.name, bson);

      serialiseNumber(element.value, bson);

      return bson;
    }

    if(element.type == JSON_ELEMENT_BOOLEAN){

      bson.value = new byte[](bson.value, BSON_BOOL);

      serialiseName(element.name, bson);

      serialiseBoolean(element.value, bson);

      return bson;
    }

    if(element.type == JSON_ELEMENT_ARRAY){
      out.println("ARRAY");
      bson.value = new byte[](bson.value, BSON_ARRAY);

      if(element.name.arrayLength == 0){
        throw new Exception("Invalid BSON structure: an array must have an associated name");
        return bson;
      }

      serialiseName(element.name, bson);

      /*
        For this, we need to know the size of our children, and thereby their structures.

        We then recursively descend into each child element, and resolve by combining
        the child with the children bson document
      */
      BSONDocument children = new BSONDocument("");

      out.println("ARRAY LENGTH $(iu.intToString(element.children.arrayLength))");

      for(int i = 0; i < element.children.arrayLength; i++){

        out.println("ARRAY CHILD:$(iu.intToString(element.children[i].type)) || $(element.children[i].name) || $(element.children[i].value)");

        JSONElement newParent = new JSONElement(element.children[i].type, iu.intToString(i), element.children[i].value, element.children[i].children);

        BSONDocument newChild = digestJSONElement(newParent);

        children.value = new byte[](children.value, newChild.value);
      }

      //after we have returned, combine the children, the childrens length
      //with our bson document.
      //it's inclusive so add 4 for an int32
      byte lengthOfChildren[] = bu.toLittleEndian(children.value.arrayLength + 5);
      bson.value = new byte[](bson.value,lengthOfChildren,children.value, BSON_NULL_TERMINATOR);

      //resolve
      return bson;
    }

    return bson;
  }


  char[] bsonReadName(char content[], int count){

    char name[] = "";

    while(content[count] != 0){
      name = new char[](name, content[count]);
      count++;
    }

    return name;
  }

  /*
    Each time this is called, the algorithm is as follows:

      * determine the size
      * get the type
      * process based on type

        IF we are processing an array or object, rip off the bson representation
        of these types and call the function again with the array of bytes,
        described by the bson.

        Otherwise, process the type, and continue reading in a while loop, until
        the end of the document is reached.
  */

  JSONElement[] digestBSONDocument(BSONDocument document){

    JSONElement elements[];

    byte content[] = document.value;

    int count = 0;

    int size = bu.toInteger(bu.reverse(su.subString(content,count,4)));

    count += 4;

    //minus one for end of object
    while(count < size - 1){

      int type = content[count];

      char name[] = bsonReadName(content,count);

      count += name.arrayLength + 1;

      if(type == BSON_EMBEDDED_DOCUMENT){

        int objectSize =  bu.toInteger(bu.reverse(su.subString(content,count,4)));

        elements = new JSONElement[](elements, new JSONElement(JSON_ELEMENT_OBJECT, name, "", digestBSONDocument(new BSONDocument(su.subString(content,count,objectSize)))));

        count += objectSize;

      }

      if(type == BSON_UTF8){

        char value[] = "";

        int valueSize = bu.toInteger(bu.reverse(su.subString(content,count,4)));

        //we've digested the size integer
        count += 4;

        int limit = count + valueSize;

        while(count < limit){
          value = new char[](value, content[count]);
          count++;
        }

        elements = new JSONElement[](elements, new JSONElement(JSON_ELEMENT_STRING, name, value, new JSONElement()));
      }

      if(type == BSON_OBJECT_ID){

        char value[] = "";

        int limit = count + 12;

        //add 48 for hexadecimal characters...
        while(count < limit){

          char newChar = content[count];

          value = new char[](value, newChar);

          count++;
        }

        elements = new JSONElement[](elements, new JSONElement(JSON_ELEMENT_STRING, name, value, new JSONElement()));
      }

      if(type == BSON_INT_32){

        int value = bu.toInteger(bu.reverse(su.subString(content,count,4)));

        //we've digested the integer
        count += 4;

        elements = new JSONElement[](elements, new JSONElement(JSON_ELEMENT_NUMBER, name, iu.intToString(value), new JSONElement()));
      }

      if(type == BSON_BOOL){

        char value[] = "";

        int boolData = content[count];

        count++;

        if(boolData == BSON_BOOL_TRUE)
          value = "true";
        else
          value = "false";

        elements = new JSONElement[](elements, new JSONElement(JSON_ELEMENT_BOOLEAN, name, iu.intToString(value), new JSONElement()));
      }

      if(type == BSON_ARRAY){

        int arraySize =  bu.toInteger(bu.reverse(su.subString(content,count,4)));

        elements = new JSONElement[](elements, new JSONElement(JSON_ELEMENT_ARRAY, name, "", digestBSONDocument(new BSONDocument(su.subString(content,count,arraySize)))));

        count += arraySize;

      }
    }

    return elements;
  }
}
