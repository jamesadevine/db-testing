uses data.String;


component provides MongoDB requires io.Output out, data.json.JSONParser parser, database.BSON bson, net.TCPSocket client, data.IntUtil iu, data.StringUtil su, util.RandomInt ri, database.ByteUtil bu, time.Calendar cal, time.DateUtil du, database.UUID uuid{

  char HOSTIP[] = "";
	int HOSTPORT = 0;

  MongoDB:MongoDB(char ip[], int port){
    //set our hostip and port for this instance.
    HOSTIP = ip;
    HOSTPORT = port;

    int rand_seed = du.toMilliseconds(cal.getTime());

    ri.setSeed(rand_seed);

    //validate connection
    connect();
    disconnect();
  }

  void connect(){
    if (client.connect(HOSTIP, HOSTPORT))
      return;
    else
      throw new Exception("No database instance is running at: $(HOSTIP):$(iu.intToString(HOSTPORT)).");
  }

  void disconnect(){
    client.disconnect();
  }

  void MongoDB:insert(char collection[], JSONElement jsonQuery[]){

    if(jsonQuery.arrayLength == 0)
      throw new Exception("An empty array is not a valid query.");

    BSONDocument queries[];

    collection = new char[](collection,0);

    for(int i = 0; i < jsonQuery.arrayLength; i++){

      JSONElement temp = jsonQuery[i];//insertID(jsonQuery[i]);

      BSONDocument doc = bson.serialise(temp);

      byte bytes[] = doc.value;

      for(int j = 0; j < bytes.arrayLength; j++){
        char charValue = bytes[j];
  			int intValue = bytes[j];
        out.println("$(iu.intToString(j+1))  \"$(charValue), $(iu.intToString(intValue))\"");
      }

      queries = new BSONDocument[](queries, doc);
    }

    //iterate queries, we write to the socket one at a time as per the spec!
    for(int i = 0; i < queries.arrayLength; i++){

      out.println("$(iu.intToString(MONGO_HEADER_SIZE + queries[i].value.arrayLength + 4 + collection.arrayLength))");

      MongoHeader mh = new MongoHeader(MONGO_HEADER_SIZE + queries[i].value.arrayLength + 4 + collection.arrayLength, ri.get(MONGO_MAX_RAND), 0, OP_INSERT);

      MongoInsert ins = new MongoInsert(0, collection, queries[i]);

      connect();
      send(serialiseMongoHeader(mh), serialiseMongoInsert(ins));
      disconnect();
    }
  }

  JSONElement[] MongoDB:find(char collection[], JSONElement jsonQuery, int32 numberToReturn){

    collection = new char[](collection,0);

    BSONDocument bsonQuery = bson.serialise(jsonQuery);

    MongoHeader mh = new MongoHeader(MONGO_HEADER_SIZE + bsonQuery.value.arrayLength + 12 + collection.arrayLength, ri.get(MONGO_MAX_RAND), 0, OP_QUERY);

    MongoQuery query = new MongoQuery(0, collection, 0, numberToReturn, bsonQuery);

    connect();

    send(serialiseMongoHeader(mh), serialiseMongoQuery(query));

    byte received[] = receive();

    disconnect();

    MongoReply responses = toMongoReply(received);

    JSONElement jsonResponses[];

    for(int i = 0; i < responses.documents.arrayLength; i++)
      jsonResponses = new JSONElement[](jsonResponses, bson.deserialise(responses.documents[i]));

    return jsonResponses;
  }

  JSONElement[] MongoDB:findWithModifier(char collection[], JSONElement jsonQuery, JSONElement modifier, int32 numberToReturn){

    collection = new char[](collection,0);

    BSONDocument bsonQuery = bson.serialise(jsonQuery);
    BSONDocument bsonModifier = bson.serialise(modifier);

    MongoHeader mh = new MongoHeader(MONGO_HEADER_SIZE + bsonQuery.value.arrayLength + bsonModifier.value.arrayLength + 12 + collection.arrayLength, ri.get(MONGO_MAX_RAND), 0, OP_QUERY);

    MongoQueryRF queryRF = new MongoQueryRF(0, collection, 0, numberToReturn, bsonQuery, bsonModifier);

    connect();

    send(serialiseMongoHeader(mh), serialiseMongoQueryRF(queryRF));

    byte received[] = receive();

    disconnect();

    MongoReply responses = toMongoReply(received);

    JSONElement jsonResponses[];

    for(int i = 0; i < responses.documents.arrayLength; i++)
      jsonResponses = new JSONElement[](jsonResponses, bson.deserialise(responses.documents[i]));

    return jsonResponses;
  }

  void MongoDB:update(char collection[], JSONElement jsonQuery, JSONElement updateObject){

    collection = new char[](collection,0);

    BSONDocument selector = bson.serialise(jsonQuery);
    BSONDocument bsonUpdate = bson.serialise(updateObject);

    MongoHeader mh = new MongoHeader(MONGO_HEADER_SIZE + selector.value.arrayLength + bsonUpdate.value.arrayLength + 8 + collection.arrayLength, ri.get(MONGO_MAX_RAND), 0, OP_UPDATE);

    MongoUpdate update = new MongoUpdate(0, collection, 0, selector, bsonUpdate);

    connect();

    send(serialiseMongoHeader(mh),serialiseMongoUpdate(update));

    disconnect();
  }

  void MongoDB:delete(char collection[], JSONElement jsonQuery){

    collection = new char[](collection,0);

    BSONDocument selector = bson.serialise(jsonQuery);

    MongoHeader mh = new MongoHeader(MONGO_HEADER_SIZE + selector.value.arrayLength + 8 + collection.arrayLength, ri.get(MONGO_MAX_RAND), 0, OP_DELETE);

    MongoDelete delete = new MongoDelete(0, collection, 0, selector);

    connect();

    send(serialiseMongoHeader(mh), serialiseMongoDelete(delete));

    disconnect();
  }

  byte[] serialiseMongoHeader(MongoHeader mh){

    byte serialised[] = bu.toLittleEndian(mh.messageLength);

    serialised = new byte[](serialised, bu.toLittleEndian(mh.requestID));
    serialised = new byte[](serialised, bu.toLittleEndian(mh.responseTo));
    serialised = new byte[](serialised, bu.toLittleEndian(mh.opCode));

    return serialised;
  }

  byte[] serialiseMongoInsert(MongoInsert ins){

    byte serialised[] = bu.toLittleEndian(ins.flags);

    serialised = new byte[](serialised, new byte[](ins.fullCollectionName));
    serialised = new byte[](serialised, new byte[](ins.document.value));

    return serialised;
  }

  byte[] serialiseMongoQuery(MongoQuery query){

    byte serialised[] = bu.toLittleEndian(query.flags);

    serialised = new byte[](serialised, new byte[](query.fullCollectionName));
    serialised = new byte[](serialised, bu.toLittleEndian(query.numberToSkip));
    serialised = new byte[](serialised, bu.toLittleEndian(query.numberToReturn));
    serialised = new byte[](serialised, new byte[](query.document.value));

    return serialised;
  }

  byte[] serialiseMongoQueryRF(MongoQueryRF queryRF){

    byte serialised[] = bu.toLittleEndian(queryRF.flags);

    serialised = new byte[](serialised, new byte[](queryRF.fullCollectionName));
    serialised = new byte[](serialised, bu.toLittleEndian(queryRF.numberToSkip));
    serialised = new byte[](serialised, bu.toLittleEndian(queryRF.numberToReturn));
    serialised = new byte[](serialised, new byte[](queryRF.document.value));
    serialised = new byte[](serialised, new byte[](queryRF.returnFieldsSelector.value));

    return serialised;
  }

  byte[] serialiseMongoDelete(MongoDelete delete){

    byte serialised[] = bu.toLittleEndian(delete.ZERO);
    serialised = new byte[](serialised, new byte[](delete.fullCollectionName));
    serialised = new byte[](serialised, bu.toLittleEndian(delete.flags));
    serialised = new byte[](serialised, new byte[](delete.document.value));

    return serialised;
  }

  byte[] serialiseMongoUpdate(MongoUpdate update){

    byte serialised[] = bu.toLittleEndian(update.ZERO);
    serialised = new byte[](serialised, new byte[](update.fullCollectionName));
    serialised = new byte[](serialised, bu.toLittleEndian(update.flags));
    serialised = new byte[](serialised, new byte[](update.selector.value));
    serialised = new byte[](serialised, new byte[](update.update.value));

    return serialised;
  }

  void send(byte header[], byte content[]){
    client.send(header);
    client.send(content);
  }

  byte[] receive(){

    byte received[];

    //the first four bytes contain message length
    received = client.recv(4);

    int32 messageLength = bu.toInteger(bu.reverse(received));

    //receive our data...
    while ((received = new byte[](received,client.recv(1))).arrayLength < messageLength);

    return received;
  }

  MongoReply toMongoReply(byte data[]){
    /*
      I acknowledge this could be done in a few lines...
      However this would be bad for readability, and understanding.

      This structure will always be the same - no matter the response.

      Mongo also communicates in little endian, dana does not, hence the conversions...
    */

    int32 messageLength = bu.toInteger(bu.reverse(su.subString(data,0,4)));
    int32 requestID = bu.toInteger(bu.reverse(su.subString(data,4,4)));
    int32 responseTo = bu.toInteger(bu.reverse(su.subString(data,8,4)));
    int32 opCode = bu.toInteger(bu.reverse(su.subString(data,12,4)));

    MongoHeader mh = new MongoHeader(messageLength,requestID,responseTo,opCode);

    int32 responseFlags = bu.toInteger(bu.reverse(su.subString(data,16,4)));
    int64 cursorID = bu.toInteger(bu.reverse(su.subString(data,20,8)));
    int32 startingFrom = bu.toInteger(bu.reverse(su.subString(data,28,4)));
    int32 numberReturned = bu.toInteger(bu.reverse(su.subString(data,32,4)));

    BSONDocument bsonDocs[] = bson.parse(su.subString(data,36, data.arrayLength - 36));

    MongoReply reply = new MongoReply(mh, responseFlags, cursorID, startingFrom, numberReturned, bsonDocs);

    return reply;
  }

  JSONElement insertID(JSONElement element){

    JSONElement newElement = element;

    if(element.type != JSON_ELEMENT_OBJECT){
      throw new Exception("Not a valid mongo object structure, JSON must be an object");
    }

    if(parser.getValue(element,"_id") == null){
      JSONElement _idObject = new JSONElement(JSON_ELEMENT_STRING, "_id", uuid.generate(32));
      JSONElement newChildren[] = new JSONElement[](_idObject,element.children);

      newElement = new JSONElement(element.type, element.name, element.value, newChildren);
    }

    return newElement;
  }

}
